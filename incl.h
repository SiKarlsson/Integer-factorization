       //C99 7.18.3 Limits of other integer types//// Footnote 219,220:C++implementations should define these macros only when// __STDC_LIMIT_MACROS is defined before<stdint.h>is included.//// Footnote 222:C++implementations should define these macros only when// __STDC_CONSTANT_MACROS is defined before<stdint.h>is included.////C++11[cstdint.syn]p2://// The macros defined by<cstdint>are provided unconditionally.In particular,// the symbols __STDC_LIMIT_MACROS and __STDC_CONSTANT_MACROS (mentioned in// footnotes 219,220,and 222 in the C standard)play no role in C++.////C11 removed the problematic footnotes.////Work around this inconsistency by always defining those macros in C++mode,//so that a C library implementation which follows the C99 standard can be//used in C++.   typedef	__signed char		int8_t; typedef	short			int16_t; typedef	int			int32_t; typedef	long long		int64_t; typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; typedef unsigned long long uint64_t; typedef int8_t  int_least8_t;typedef int16_t  int_least16_t;typedef int32_t  int_least32_t;typedef int64_t  int_least64_t;typedef uint8_t  uint_least8_t;typedef uint16_t uint_least16_t;typedef uint32_t uint_least32_t;typedef uint64_t uint_least64_t; typedef int8_t  int_fast8_t;typedef int16_t  int_fast16_t;typedef int32_t  int_fast32_t;typedef int64_t  int_fast64_t;typedef uint8_t  uint_fast8_t;typedef uint16_t uint_fast16_t;typedef uint32_t uint_fast32_t;typedef uint64_t uint_fast64_t;            #if 1  #else  #endif  #if 1  #else  #endif                                                                        typedef __signed char		__int8_t; typedef unsigned char		__uint8_t;typedef	short			__int16_t;typedef	unsigned short		__uint16_t;typedef int			__int32_t;typedef unsigned int		__uint32_t;typedef long long		__int64_t;typedef unsigned long long	__uint64_t; typedef long			__darwin_intptr_t;typedef unsigned int		__darwin_natural_t; typedef int			__darwin_ct_rune_t;	 typedef union{	char		__mbstate8[128];	long long	_mbstateL;			}__mbstate_t; typedef __mbstate_t		__darwin_mbstate_t;	 typedef int	__darwin_ptrdiff_t;	 typedef long unsigned int		__darwin_size_t;	 typedef __builtin_va_list	__darwin_va_list;	 typedef int		__darwin_wchar_t;	 typedef __darwin_wchar_t	__darwin_rune_t;	 typedef int		__darwin_wint_t;	 typedef unsigned long		__darwin_clock_t;	typedef __uint32_t		__darwin_socklen_t;	typedef long			__darwin_ssize_t;	typedef long			__darwin_time_t;	  typedef	__int64_t	__darwin_blkcnt_t;	typedef	__int32_t	__darwin_blksize_t;	typedef __int32_t	__darwin_dev_t;		typedef unsigned int	__darwin_fsblkcnt_t;	typedef unsigned int	__darwin_fsfilcnt_t;	typedef __uint32_t	__darwin_gid_t;		typedef __uint32_t	__darwin_id_t;		typedef __uint64_t	__darwin_ino64_t;	 typedef __darwin_ino64_t __darwin_ino_t;	 typedef __darwin_natural_t __darwin_mach_port_name_t; typedef __darwin_mach_port_name_t __darwin_mach_port_t; typedef __uint16_t	__darwin_mode_t;	typedef __int64_t	__darwin_off_t;		typedef __int32_t	__darwin_pid_t;		typedef __uint32_t	__darwin_sigset_t;	typedef __int32_t	__darwin_suseconds_t;	typedef __uint32_t	__darwin_uid_t;		typedef __uint32_t	__darwin_useconds_t;	typedef	unsigned char	__darwin_uuid_t[16];typedef	char	__darwin_uuid_string_t[37]; //pthread opaque structures struct __darwin_pthread_handler_rec{	void (*__routine)(void*);	//Routine to call	void*__arg;			//Argument to pass	struct __darwin_pthread_handler_rec*__next;}; struct _opaque_pthread_attr_t{	long __sig;	char __opaque[36];}; struct _opaque_pthread_cond_t{	long __sig;	char __opaque[24];}; struct _opaque_pthread_condattr_t{	long __sig;	char __opaque[4];}; struct _opaque_pthread_mutex_t{	long __sig;	char __opaque[40];}; struct _opaque_pthread_mutexattr_t{	long __sig;	char __opaque[8];}; struct _opaque_pthread_once_t{	long __sig;	char __opaque[4];}; struct _opaque_pthread_rwlock_t{	long __sig;	char __opaque[124];}; struct _opaque_pthread_rwlockattr_t{	long __sig;	char __opaque[12];}; struct _opaque_pthread_t{	long __sig;	struct __darwin_pthread_handler_rec*__cleanup_stack;	char __opaque[4088];}; typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;typedef unsigned long __darwin_pthread_key_t;typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;typedef struct _opaque_pthread_t*__darwin_pthread_t;  typedef __darwin_intptr_t	intptr_t; typedef unsigned long		uintptr_t;  typedef long long int intmax_t; typedef long long unsigned int uintmax_t;                     //for uint64_t and int64_t on a 32 bit platform   			 		//we're using a 32bit platform			   	 	  namespace ttmath{ 		typedef unsigned int uint;	typedef __signed int sint;		 		//we do not use 'long' here because there is a difference in unix and windows		//environments:in unix 'long' has 64 bits but in windows it has only 32 bits		typedef uint64_t ulint;		typedef int64_t slint;						 		 		 	}   	#ifdef 4			#else			#endif   namespace ttmath{	 	enum LibTypeCode	{	 asm_vc_32=0,	 asm_gcc_32,	 asm_vc_64,	 asm_gcc_64,	 no_asm_32,	 no_asm_64	};		enum ErrorCode	{		err_ok=0,		err_nothing_has_read,		err_unknown_character,		err_unexpected_final_bracket,		err_stack_not_clear,		err_unknown_variable,		err_division_by_zero,		err_interrupt,		err_overflow,		err_unknown_function,		err_unknown_operator,		err_unexpected_semicolon_operator,		err_improper_amount_of_arguments,		err_improper_argument,		err_unexpected_end,		err_internal_error,		err_incorrect_name,		err_incorrect_value,		err_variable_exists,		err_variable_loop,		err_functions_loop,		err_must_be_only_one_value,		err_object_exists,		err_unknown_object,		err_still_calculating,		err_in_short_form_used_function,		err_percent_from	};	 	struct Conv	{		 		uint base;		 		bool scient;		 		sint scient_from;				bool base_round;				sint round;		 		bool trim_zeroes;		 		uint comma;		 		uint comma2;		 		uint group;		 		uint group_digits;				uint group_exp;//not implemented yet 		Conv()		{			//default values			base =10;			scient =false;			scient_from=15;			base_round =true;			round =-1;			trim_zeroes=true;			comma ='.';			comma2 =',';			group =0;			group_digits=3;			group_exp =0;		}	}; 		class StopCalculating	{	public:		virtual bool WasStopSignal()__const __volatile{return false;}		virtual~StopCalculating(){}	};	 	class ExceptionInfo	{	__const char*file;	int line;	public:		ExceptionInfo():file(0),line(0){}		ExceptionInfo(__const char*f,int l):file(f),line(l){}		string Where()__const		{			if(!file)				return"unknown";			ostringstream result;			result<<file<<":"<<line;		return result.str();		}	};		class ReferenceError:public logic_error,public ExceptionInfo	{	public:		ReferenceError():logic_error("reference error")		{		}		ReferenceError(__const char*f,int l):							logic_error("reference error"),ExceptionInfo(f,l)		{		}		string Where()__const		{			return ExceptionInfo::Where();		}	};		class RuntimeError:public runtime_error,public ExceptionInfo	{	public:		RuntimeError():runtime_error("internal error")		{		}		RuntimeError(__const char*f,int l):						runtime_error("internal error"),ExceptionInfo(f,l)		{		}		string Where()__const		{			return ExceptionInfo::Where();		}	}; 		 			#define TTMATH_REFERENCE_ASSERT(expression)			#endif 	 		#define TTMATH_LOG(msg)				#define TTMATH_VECTOR_LOG(msg,vector,len)			#endif }//namespace    namespace ttmath{ class Misc{public:  static void AssignString(string&result,__const char*str){	result=str;} static void AssignString(wstring&result,__const char*str){	result.clear();	for(;*str;++str)		result+=*str;} static void AssignString(wstring&result,__const string&str){	return AssignString(result,str.c_str());} static void AssignString(string&result,__const wchar_t*str){	result.clear();	for(;*str;++str)		result+=static_cast<char>(*str);} static void AssignString(string&result,__const wstring&str){	return AssignString(result,str.c_str());}  static void AddString(string&result,__const char*str){	result+=str;} static void AddString(wstring&result,__const char*str){	for(;*str;++str)		result+=*str;} template<class char_type>static void SkipWhiteCharacters(__const char_type*&c){	//13 is at the end in a DOS text file (\r\n)	while((*c==' ')||(*c=='\t')||(*c==13)||(*c=='\n'))		++c;} static uint CharToDigit(uint c){	if(c>='0'&&c<='9')		return c-'0';	if(c>='a'&&c<='z')		return c-'a'+10; return c-'A'+10;}  static sint CharToDigit(uint c,uint base){	if(c>='0'&&c<='9')		c=c-'0';	else	if(c>='a'&&c<='z')		c=c-'a'+10;	else	if(c>='A'&&c<='Z')		c=c-'A'+10;	else		return-1;	if(c>=base)		return-1; return sint(c);} static uint DigitToChar(uint digit){	if(digit<10)		return digit+'0'; return digit-10+'A';}};//struct Misc}  namespace ttmath{  template<uint value_size>class UInt{public:	 	uint table[value_size]; 	 	 	template<class ostream_type>	void PrintTable(ostream_type&output)__const	{		//how many columns there'll be		__const int columns=8;		int c=1;		for(int i=value_size-1;i>=0;--i)		{			output<<"0x"<<setfill('0');										output<<setw(8);										output<<hex<<table[i];						if(i>0)			{				output<<",";									if(++c>columns)				{					output<<endl;					c=1;				}			}		}				output<<dec<<endl;	}		template<class char_type,class ostream_type>	static void PrintVectorLog(__const char_type*msg,ostream_type&output,__const uint*vector,uint vector_len)	{		output<<msg<<endl;		for(uint i=0;i<vector_len;++i)			output<<"table["<<i<<"]:"<<vector[i]<<endl;	}		template<class char_type,class ostream_type>	static void PrintVectorLog(__const char_type*msg,uint carry,ostream_type&output,__const uint*vector,uint vector_len)	{		PrintVectorLog(msg,output,vector,vector_len);		output<<"carry:"<<carry<<endl;	}		template<class char_type,class ostream_type>	void PrintLog(__const char_type*msg,ostream_type&output)__const	{		PrintVectorLog(msg,output,table,value_size);	}		template<class char_type,class ostream_type>	void PrintLog(__const char_type*msg,uint carry,ostream_type&output)__const	{		PrintVectorLog(msg,output,table,value_size);		output<<"carry:"<<carry<<endl;	}		uint Size()__const	{		return value_size;	}		void SetZero()	{		//in the future here can be 'memset'		for(uint i=0;i<value_size;++i)			table[i]=0;		TTMATH_LOG("UInt::SetZero")	}		void SetOne()	{		SetZero();		table[0]=1;		TTMATH_LOG("UInt::SetOne")	}	 	void SetMax()	{		for(uint i=0;i<value_size;++i)			table[i]=4294967295u;		TTMATH_LOG("UInt::SetMax")	}	 	void SetMin()	{		SetZero();		TTMATH_LOG("UInt::SetMin")	}		void Swap(UIntS&ss2)	{		for(uint i=0;i<value_size;++i)		{			uint temp=table[i];			table[i]=ss2.table[i];			ss2.table[i]=temp;		}	} 		void SetFromTable(__const uint*temp_table,uint temp_table_len)	{		uint temp_table_index=0;		sint i;//'i' with a sign		for(i=value_size-1;i>=0&&temp_table_index<temp_table_len;--i,++temp_table_index)			table[i]=temp_table[temp_table_index];		//rounding mantissa		if(temp_table_index<temp_table_len)		{			if((temp_table[temp_table_index]&2147483648u)!=0)			{								if(table[0]!=4294967295u)					++table[0];			}		}		//cleaning the rest of the mantissa		for(;i>=0;--i)			table[i]=0;		TTMATH_LOG("UInt::SetFromTable")	} 	 		uint AddOne()	{		return AddInt(1);	}		uint SubOne()	{		return SubInt(1);	} private:	 	void RclMoveAllWords(uint&rest_bits,uint&last_c,uint bits,uint c)	{		rest_bits =bits %32u;		uint all_words=bits/32u;		uint mask =(c)?4294967295u:0;		if(all_words>=value_size)		{			if(all_words==value_size&&rest_bits==0)				last_c=table[0]&1;			//else:last_c is default set to 0			//clearing			for(uint i=0;i<value_size;++i)				table[i]=mask;			rest_bits=0;		}		else		if(all_words>0)		{			//0<all_words<value_size				sint first,second;			last_c=table[value_size-all_words]&1;//all_words is greater than 0			//copying the first part of the value			for(first=value_size-1,second=first-all_words;second>=0;--first,--second)				table[first]=table[second];			//setting the rest to 'c'			for(;first>=0;--first)				table[first]=mask;		}		TTMATH_LOG("UInt::RclMoveAllWords")	}	public:		uint Rcl(uint bits,uint c=0)	{	uint last_c =0;	uint rest_bits=bits;		if(bits==0)			return 0;		if(bits>=32u)			RclMoveAllWords(rest_bits,last_c,bits,c);		if(rest_bits==0)		{			TTMATH_LOG("UInt::Rcl")			return last_c;		}		//rest_bits is from 1 to 32u-1 now		if(rest_bits==1)		{			last_c=Rcl2_one(c);		}		else if(rest_bits==2)		{			//performance tests showed that for rest_bits==2 it's better to use Rcl2_one twice instead of Rcl2(2,c)			Rcl2_one(c);			last_c=Rcl2_one(c);		}		else		{			last_c=Rcl2(rest_bits,c);		}			return last_c;	} private:	 	void RcrMoveAllWords(uint&rest_bits,uint&last_c,uint bits,uint c)	{		rest_bits =bits %32u;		uint all_words=bits/32u;		uint mask =(c)?4294967295u:0;		if(all_words>=value_size)		{			if(all_words==value_size&&rest_bits==0)				last_c=(table[value_size-1]&2147483648u)?1:0;			//else:last_c is default set to 0			//clearing			for(uint i=0;i<value_size;++i)				table[i]=mask;			rest_bits=0;		}		else if(all_words>0)		{			//0<all_words<value_size			uint first,second;			last_c=(table[all_words-1]&2147483648u)?1:0;//all_words is>0			//copying the first part of the value			for(first=0,second=all_words;second<value_size;++first,++second)				table[first]=table[second];			//setting the rest to 'c'			for(;first<value_size;++first)				table[first]=mask;		}		TTMATH_LOG("UInt::RcrMoveAllWords")	} public:		uint Rcr(uint bits,uint c=0)	{	uint last_c =0;	uint rest_bits=bits;			if(bits==0)			return 0;		if(bits>=32u)			RcrMoveAllWords(rest_bits,last_c,bits,c);		if(rest_bits==0)		{			TTMATH_LOG("UInt::Rcr")			return last_c;		}		//rest_bits is from 1 to 32u-1 now		if(rest_bits==1)		{			last_c=Rcr2_one(c);		}		else if(rest_bits==2)		{			//performance tests showed that for rest_bits==2 it's better to use Rcr2_one twice instead of Rcr2(2,c)			Rcr2_one(c);			last_c=Rcr2_one(c);		}		else		{			last_c=Rcr2(rest_bits,c);		}			return last_c;	}	 	uint CompensationToLeft()	{		uint moving=0;		//a-index a last word which is different from zero		sint a;		for(a=value_size-1;a>=0&&table[a]==0;--a);		if(a<0)			return moving;//all words in table have zero		if(a!=value_size-1)		{			moving+=(value_size-1-a)*32u;			//moving all words			sint i;			for(i=value_size-1;a>=0;--i,--a)				table[i]=table[a];			//setting the rest word to zero			for(;i>=0;--i)				table[i]=0;		}		uint moving2=FindLeadingBitInWord(table[value_size-1]);		//moving2 is different from-1 because the value table[value_size-1]		//is not zero		moving2=32u-moving2-1;		Rcl(moving2);		TTMATH_LOG("UInt::CompensationToLeft")	return moving+moving2;	}		bool FindLeadingBit(uint&table_id,uint&index)__const	{		for(table_id=value_size-1;table_id!=0&&table[table_id]==0;--table_id);		if(table_id==0&&table[table_id]==0)		{			//is zero			index=0;		return false;		}				//table[table_id]is different from 0		index=FindLeadingBitInWord(table[table_id]);	return true;	}		bool FindLowestBit(uint&table_id,uint&index)__const	{		for(table_id=0;table_id<value_size&&table[table_id]==0;++table_id);		if(table_id>=value_size)		{			//is zero			index =0;			table_id=0;		return false;		}				//table[table_id]is different from 0		index=FindLowestBitInWord(table[table_id]);	return true;	}	 	uint GetBit(uint bit_index)__const	{				uint index=bit_index/32u;		uint bit =bit_index %32u;		uint temp=table[index];		uint res=SetBitInWord(temp,bit);	return res;	}	 	uint SetBit(uint bit_index)	{				uint index=bit_index/32u;		uint bit =bit_index %32u;		uint res =SetBitInWord(table[index],bit);		TTMATH_LOG("UInt::SetBit")	return res;	}		void BitAnd(__const UIntS&ss2)	{		for(uint x=0;x<value_size;++x)			table[x]&=ss2.table[x];		TTMATH_LOG("UInt::BitAnd")	}		void BitOr(__const UIntS&ss2)	{		for(uint x=0;x<value_size;++x)			table[x]|=ss2.table[x];		TTMATH_LOG("UInt::BitOr")	}		void BitXor(__const UIntS&ss2)	{		for(uint x=0;x<value_size;++x)			table[x]^=ss2.table[x];		TTMATH_LOG("UInt::BitXor")	}		void BitNot()	{		for(uint x=0;x<value_size;++x)			table[x]=~table[x];		TTMATH_LOG("UInt::BitNot")	}	 	void BitNot2()	{	uint table_id,index;		if(FindLeadingBit(table_id,index))		{			for(uint x=0;x<table_id;++x)				table[x]=~table[x];			uint mask=4294967295u;			uint shift=32u-index-1;			if(shift)				mask>>=shift;			table[table_id]^=mask;		}		else			table[0]=1;		TTMATH_LOG("UInt::BitNot2")	} 	 public:	 	uint MulInt(uint ss2)	{	uint r1,r2,x1;	uint c=0;		UIntSu(*this);		SetZero();		if(ss2==0)		{						return 0;		}		for(x1=0;x1<value_size-1;++x1)		{			MulTwoWords(u.table[x1],ss2,&r2,&r1);			c+=AddTwoInts(r2,r1,x1);		}		//x1=value_size-1 (last word)		MulTwoWords(u.table[x1],ss2,&r2,&r1);		c+=(r2!=0)?1:0;		c+=AddInt(r1,x1);			return (c==0)?0:1;	}	 	template<uint result_size>	void MulInt(uint ss2,UInt<result_size>&result)__const	{		uint r2,r1;	uint x1size=value_size;	uint x1start=0;		result.SetZero();		if(ss2==0)		{			TTMATH_VECTOR_LOG("UInt::MulInt(uint,UInt<>)",result.table,result_size)			return;		}		if(value_size>2)		{				//if the value_size is smaller than or equal to 2			//there is no sense to set x1size and x1start to another values			for(x1size=value_size;x1size>0&&table[x1size-1]==0;--x1size);			if(x1size==0)			{				TTMATH_VECTOR_LOG("UInt::MulInt(uint,UInt<>)",result.table,result_size)				return;			}			for(x1start=0;x1start<x1size&&table[x1start]==0;++x1start);		}		for(uint x1=x1start;x1<x1size;++x1)		{			MulTwoWords(table[x1],ss2,&r2,&r1);			result.AddTwoInts(r2,r1,x1);		}		TTMATH_VECTOR_LOG("UInt::MulInt(uint,UInt<>)",result.table,result_size)	return;	} 	 	uint Mul(__const UIntS&ss2,uint algorithm=100)	{		switch(algorithm)		{		case 1:			return Mul1(ss2);		case 2:			return Mul2(ss2);		case 3:			return Mul3(ss2);		case 100:		default:			return MulFastest(ss2);		}	}	 	void MulBig(__const UIntS&ss2,				UInt<value_size*2>&result,				uint algorithm=100)	{		switch(algorithm)		{		case 1:			return Mul1Big(ss2,result);		case 2:			return Mul2Big(ss2,result);		case 3:			return Mul3Big(ss2,result);		case 100:		default:			return MulFastestBig(ss2,result);		}	} 	 private:	 	uint Mul1Ref(__const UIntS&ss2)	{	TTMATH_REFERENCE_ASSERT(ss2)	UIntSss1(*this);	SetZero();			for(uint i=0;i<value_size*32u;++i)		{			if(Add(*this))			{								return 1;			}			if(ss1.Rcl(1))				if(Add(ss2))				{										return 1;				}		}			return 0;	} public:	 	uint Mul1(__const UIntS&ss2)	{		if(this==&ss2)		{			UIntScopy_ss2(ss2);			return Mul1Ref(copy_ss2);		}		else		{			return Mul1Ref(ss2);		}	}		 	void Mul1Big(__const UIntS&ss2_,UInt<value_size*2>&result)	{	UInt<value_size*2>ss2;	uint i;		//copying*this into result and ss2_ into ss2		for(i=0;i<value_size;++i)		{			result.table[i]=table[i];			ss2.table[i] =ss2_.table[i];		}		//cleaning the highest bytes in result and ss2		for(;i<value_size*2;++i)		{			result.table[i]=0;			ss2.table[i] =0;		}		//multiply		//(there will not be a carry)		result.Mul1(ss2);		TTMATH_LOG("UInt::Mul1Big")	} 	 	 	uint Mul2(__const UIntS&ss2)	{	UInt<value_size*2>result;	uint i,c=0;		Mul2Big(ss2,result);			//copying result		for(i=0;i<value_size;++i)			table[i]=result.table[i];		//testing carry		for(;i<value_size*2;++i)			if(result.table[i]!=0)			{				c=1;				break;			}			return c;	}	 	void Mul2Big(__const UIntS&ss2,UInt<value_size*2>&result)	{		Mul2Big2S(table,ss2.table,result);		TTMATH_LOG("UInt::Mul2Big")	} private:	 	template<uint ss_size>	void Mul2Big2(__const uint*ss1,__const uint*ss2,UInt<ss_size*2>&result)	{	uint x1size=ss_size,x2size=ss_size;	uint x1start=0, x2start=0;		if(ss_size>2)		{				//if the ss_size is smaller than or equal to 2			//there is no sense to set x1size (and others)to another values			for(x1size=ss_size;x1size>0&&ss1[x1size-1]==0;--x1size);			for(x2size=ss_size;x2size>0&&ss2[x2size-1]==0;--x2size);			for(x1start=0;x1start<x1size&&ss1[x1start]==0;++x1start);			for(x2start=0;x2start<x2size&&ss2[x2start]==0;++x2start);		}		Mul2Big3<ss_size>(ss1,ss2,result,x1start,x1size,x2start,x2size);	} 		template<uint ss_size>	void Mul2Big3(__const uint*ss1,__const uint*ss2,UInt<ss_size*2>&result,uint x1start,uint x1size,uint x2start,uint x2size)	{	uint r2,r1;		result.SetZero();		if(x1size==0||x2size==0)			return;		for(uint x1=x1start;x1<x1size;++x1)		{			for(uint x2=x2start;x2<x2size;++x2)			{				MulTwoWords(ss1[x1],ss2[x2],&r2,&r1);				result.AddTwoInts(r2,r1,x2+x1);				//here will never be a carry			}		}	} public:		uint Mul3(__const UIntS&ss2)	{	UInt<value_size*2>result;	uint i,c=0;		Mul3Big(ss2,result);			//copying result		for(i=0;i<value_size;++i)			table[i]=result.table[i];		//testing carry		for(;i<value_size*2;++i)			if(result.table[i]!=0)			{				c=1;				break;			}			return c;	} 	 	void Mul3Big(__const UIntS&ss2,UInt<value_size*2>&result)	{		Mul3Big2S(table,ss2.table,result.table);		TTMATH_LOG("UInt::Mul3Big")	} private:	 	template<uint ss_size>	void Mul3Big2(__const uint*ss1,__const uint*ss2,uint*result)	{	__const uint*x1,*x0,*y1,*y0;		if(ss_size>1&&ss_size<5)		{			UInt<ss_size*2>res;			Mul2Big2<ss_size>(ss1,ss2,res);#pragma clang diagnostic push#pragma clang diagnostic ignored"-Wtautological-compare"			for(uint i=0;i<ss_size*2;++i)				result[i]=res.table[i];#pragma clang diagnostic pop 		return;		}		else		if(ss_size==1)		{			return MulTwoWords(*ss1,*ss2,&result[1],&result[0]);		}		if((ss_size&1)==1)		{			//ss_size is odd			x0=ss1;			y0=ss2;			x1=ss1+ss_size/2+1;			y1=ss2+ss_size/2+1;			//the second vectors (x1 and y1)are smaller about one from the first ones (x0 and y0)			Mul3Big3<ss_size/2+1,ss_size/2,ss_size*2>(x1,x0,y1,y0,result);		}		else		{			//ss_size is even			x0=ss1;			y0=ss2;			x1=ss1+ss_size/2;			y1=ss2+ss_size/2;						//all four vectors (x0 x1 y0 y1)are equal in size			Mul3Big3<ss_size/2,ss_size/2,ss_size*2>(x1,x0,y1,y0,result);		}	} 		template<uint first_size,uint second_size,uint result_size>	void Mul3Big3(__const uint*x1,__const uint*x0,__const uint*y1,__const uint*y0,uint*result)	{	uint i,c,xc,yc;		UInt<first_size> temp,temp2;		UInt<first_size*3>z1;		//z0 and z2 we store directly in the result (we don't use any temporary variables)		Mul3Big2<first_size>(x0,y0,result);  //z0		Mul3Big2<second_size>(x1,y1,result+first_size*2); //z2		//now we calculate z1		//temp=(x0+x1)		//temp2=(y0+y1)		//we're using temp and temp2 with UInt<first_size>,although there can be a carry but		//we simple remember it in xc and yc (xc and yc can be either 0 or 1),		//and (x0+x1)*(y0+y1)we calculate in this way (schoolbook algorithm):		//		//  xc | temp		//  yc | temp2		//  --------------------		//  (temp * temp2)		//  xc*temp2|		//  yc*temp|		// xc*yc|   		// ---------- z1 --------		//		//and the result is never larger in size than 3*first_size		xc=AddVector(x0,x1,first_size,second_size,temp.table);		yc=AddVector(y0,y1,first_size,second_size,temp2.table);		Mul3Big2<first_size>(temp.table,temp2.table,z1.table);#pragma clang diagnostic push#pragma clang diagnostic ignored"-Wtautological-compare"		//clearing the rest of z1		for(i=first_size*2;i<first_size*3;++i)			z1.table[i]=0;#pragma clang diagnostic pop				if(xc)		{			c=AddVector(z1.table+first_size,temp2.table,first_size*3-first_size,first_size,z1.table+first_size);					}		if(yc)		{			c=AddVector(z1.table+first_size,temp.table,first_size*3-first_size,first_size,z1.table+first_size);					}		if(xc&&yc)		{#pragma clang diagnostic push#pragma clang diagnostic ignored"-Wtautological-compare"			for(i=first_size*2;i<first_size*3;++i)				if(++z1.table[i]!=0)					break;//break if there was no carry #pragma clang diagnostic pop		}		//z1=z1-z2		c=SubVector(z1.table,result+first_size*2,first_size*3,second_size*2,z1.table);				//z1=z1-z0		c=SubVector(z1.table,result,first_size*3,first_size*2,z1.table);				//here we've calculated the z1		//now we're adding it to the result		if(first_size>second_size)		{			uint z1_size=result_size-first_size;			#pragma clang diagnostic push#pragma clang diagnostic ignored"-Wtautological-compare"			for(i=z1_size;i<first_size*3;++i)			{							}#pragma clang diagnostic pop 						c=AddVector(result+first_size,z1.table,result_size-first_size,z1_size,result+first_size);					}		else		{			c=AddVector(result+first_size,z1.table,result_size-first_size,first_size*3,result+first_size);					}	} public:		uint MulFastest(__const UIntS&ss2)	{	UInt<value_size*2>result;	uint i,c=0;		MulFastestBig(ss2,result);			//copying result		for(i=0;i<value_size;++i)			table[i]=result.table[i];		//testing carry		for(;i<value_size*2;++i)			if(result.table[i]!=0)			{				c=1;				break;			}			return c;	}	 	void MulFastestBig(__const UIntS&ss2,UInt<value_size*2>&result)	{		if(value_size<5)			return Mul2Big(ss2,result);		uint x1size=value_size,x2size=value_size;		uint x1start=0,  x2start=0;		for(x1size=value_size;x1size>0&&table[x1size-1]==0;--x1size);		for(x2size=value_size;x2size>0&&ss2.table[x2size-1]==0;--x2size);		if(x1size==0||x2size==0)		{			//either 'this' or 'ss2' is equal zero-the result is zero too			result.SetZero();			return;		}		for(x1start=0;x1start<x1size&&table[x1start]==0;++x1start);		for(x2start=0;x2start<x2size&&ss2.table[x2start]==0;++x2start);		uint distancex1=x1size-x1start;		uint distancex2=x2size-x2start;		if(distancex1<3||distancex2<3)			//either 'this' or 'ss2' have only 2 (or 1)items different from zero (side by side)			//(this condition in the future can be improved)			return Mul2Big3S(table,ss2.table,result,x1start,x1size,x2start,x2size);		//Karatsuba multiplication		Mul3Big(ss2,result);		TTMATH_LOG("UInt::MulFastestBig")	}	 	public:	 	uint DivInt(uint divisor,uint*remainder=0)	{		if(divisor==0)		{			if(remainder)				*remainder=0;//this is for convenience,without it the compiler can report that 'remainder' is uninitialized			TTMATH_LOG("UInt::DivInt")		return 1;		}		if(divisor==1)		{			if(remainder)				*remainder=0;			TTMATH_LOG("UInt::DivInt")		return 0;		}		UIntSdividend(*this);		SetZero();				sint i;//i must be with a sign		uint r=0;		//we're looking for the last word in ss1		for(i=value_size-1;i>0&&dividend.table[i]==0;--i);		for(;i>=0;--i)			DivTwoWords(r,dividend.table[i],divisor,&table[i],&r);		if(remainder)			*remainder=r;		TTMATH_LOG("UInt::DivInt")	return 0;	}	uint DivInt(uint divisor,uint&remainder)	{		return DivInt(divisor,&remainder);	} 	 	uint Div(	__const UIntS&divisor,				UIntS*remainder=0,				uint algorithm=3)	{		switch(algorithm)		{		case 1:			return Div1(divisor,remainder);		case 2:			return Div2(divisor,remainder);		case 3:		default:			return Div3(divisor,remainder);		}	}	uint Div(__const UIntS&divisor,UIntS&remainder,uint algorithm=3)	{		return Div(divisor,&remainder,algorithm);	} private:	 	uint Div_StandardTest(	__const UIntS&v,							uint&m,uint&n,							UIntS*remainder=0)	{		switch(Div_CalculatingSize(v,m,n))		{		case 4://'this' is equal v			if(remainder)				remainder->SetZero();			SetOne();			TTMATH_LOG("UInt::Div_StandardTest")			return 0;		case 3://'this' is smaller than v			if(remainder)				*remainder=*this;			SetZero();			TTMATH_LOG("UInt::Div_StandardTest")			return 0;		case 2://'this' is zero			if(remainder)				remainder->SetZero();			SetZero();			TTMATH_LOG("UInt::Div_StandardTest")			return 0;		case 1://v is zero			TTMATH_LOG("UInt::Div_StandardTest")			return 1;		}		TTMATH_LOG("UInt::Div_StandardTest")	return 2;	} 		uint Div_CalculatingSize(__const UIntS&v,uint&m,uint&n)	{		m=n=value_size-1;		for(;n!=0&&v.table[n]==0;--n);		if(n==0&&v.table[n]==0)			return 1;		for(;m!=0&&table[m]==0;--m);		if(m==0&&table[m]==0)			return 2;		if(m<n)			return 3;		else		if(m==n)		{			uint i;			for(i=n;i!=0&&table[i]==v.table[i];--i);						if(table[i]<v.table[i])				return 3;			else			if (table[i]==v.table[i])				return 4;		}	return 0;	} public:	 	uint Div1(__const UIntS&divisor,UIntS*remainder=0)	{	uint m,n,test;		test=Div_StandardTest(divisor,m,n,remainder);		if(test<2)			return test;		if(!remainder)		{			UIntSrem;			return Div1_Calculate(divisor,rem);		}	return Div1_Calculate(divisor,*remainder);	}	 	uint Div1(__const UIntS&divisor,UIntS&remainder)	{		return Div1(divisor,&remainder);	} private:	uint Div1_Calculate(__const UIntS&divisor,UIntS&rest)	{		if(this==&divisor)		{			UIntSdivisor_copy(divisor);			return Div1_CalculateRef(divisor_copy,rest);		}		else		{			return Div1_CalculateRef(divisor,rest);		}	}	uint Div1_CalculateRef(__const UIntS&divisor,UIntS&rest)	{	TTMATH_REFERENCE_ASSERT(divisor)		sint loop;	sint c;		rest.SetZero();		loop=value_size*32u;		c=0;			div_a:		c=Rcl(1,c);		c=rest.Add(rest,c);		c=rest.Sub(divisor,c);		c=!c;		if(!c)			goto div_d;	div_b:		--loop;		if(loop)			goto div_a;		c=Rcl(1,c);		TTMATH_LOG("UInt::Div1_Calculate")		return 0;	div_c:		c=Rcl(1,c);		c=rest.Add(rest,c);		c=rest.Add(divisor);		if(c)			goto div_b;	div_d:		--loop;		if(loop)			goto div_c;		c=Rcl(1,c);		c=rest.Add(divisor);		TTMATH_LOG("UInt::Div1_Calculate")	return 0;	}	 public:	 	uint Div2(__const UIntS&divisor,UIntS*remainder=0)	{		if(this==&divisor)		{			UIntSdivisor_copy(divisor);			return Div2Ref(divisor_copy,remainder);		}		else		{			return Div2Ref(divisor,remainder);		}	}	 	uint Div2(__const UIntS&divisor,UIntS&remainder)	{		return Div2(divisor,&remainder);	} private:	 	uint Div2Ref(__const UIntS&divisor,UIntS*remainder=0)	{		uint bits_diff;		uint status=Div2_Calculate(divisor,remainder,bits_diff);		if(status<2)			return status;		if(CmpBiggerEqual(divisor))		{			Div2(divisor,remainder);			SetBit(bits_diff);		}		else		{			if(remainder)				*remainder=*this;			SetZero();			SetBit(bits_diff);		}		TTMATH_LOG("UInt::Div2")	return 0;	}	 	uint Div2_Calculate(__const UIntS&divisor,UIntS*remainder,															uint&bits_diff)	{	uint table_id,index;	uint divisor_table_id,divisor_index;		uint status=Div2_FindLeadingBitsAndCheck(	divisor,remainder,													table_id,index,													divisor_table_id,divisor_index);		if(status<2)		{			TTMATH_LOG("UInt::Div2_Calculate")			return status;		}				//here we know that 'this' is greater than divisor		//then 'index' is greater or equal 'divisor_index'		bits_diff=index-divisor_index;		UIntSdivisor_copy(divisor);		divisor_copy.Rcl(bits_diff,0);		if(CmpSmaller(divisor_copy,table_id))		{			divisor_copy.Rcr(1);			--bits_diff;		}		Sub(divisor_copy,0);		TTMATH_LOG("UInt::Div2_Calculate")	return 2;	}	 	uint Div2_FindLeadingBitsAndCheck(	__const UIntS&divisor,										UIntS*remainder,										uint&table_id,uint&index,										uint&divisor_table_id,uint&divisor_index)	{		if(!divisor.FindLeadingBit(divisor_table_id,divisor_index))		{			//division by zero			TTMATH_LOG("UInt::Div2_FindLeadingBitsAndCheck")			return 1;		}		if(	!FindLeadingBit(table_id,index))		{			//zero is divided by something						SetZero();			if(remainder)				remainder->SetZero();			TTMATH_LOG("UInt::Div2_FindLeadingBitsAndCheck")		return 0;		}			divisor_index+=divisor_table_id*32u;		index +=table_id *32u;		if(divisor_table_id==0)		{			//dividor has only one 32-bit word			uint r;			DivInt(divisor.table[0],&r);			if(remainder)			{				remainder->SetZero();				remainder->table[0]=r;			}			TTMATH_LOG("UInt::Div2_FindLeadingBitsAndCheck")		return 0;		}			if(Div2_DivisorGreaterOrEqual(	divisor,remainder,										table_id,index,										divisor_index))		{			TTMATH_LOG("UInt::Div2_FindLeadingBitsAndCheck")			return 0;		}		TTMATH_LOG("UInt::Div2_FindLeadingBitsAndCheck")	return 2;	}	 	bool Div2_DivisorGreaterOrEqual(	__const UIntS&divisor,										UIntS*remainder,										uint table_id,uint index,										uint divisor_index)	{		if(divisor_index>index)		{			//divisor is greater than this			if(remainder)				*remainder=*this;			SetZero();			TTMATH_LOG("UInt::Div2_DivisorGreaterOrEqual")		return true;		}		if(divisor_index==index)		{			//table_id==divisor_table_id as well			uint i;			for(i=table_id;i!=0&&table[i]==divisor.table[i];--i);						if(table[i]<divisor.table[i])			{				//divisor is greater than 'this'				if(remainder)					*remainder=*this;				SetZero();				TTMATH_LOG("UInt::Div2_DivisorGreaterOrEqual")			return true;			}			else			if(table[i]==divisor.table[i])			{				//divisor is equal 'this'				if(remainder)					remainder->SetZero();				SetOne();				TTMATH_LOG("UInt::Div2_DivisorGreaterOrEqual")			return true;			}		}		TTMATH_LOG("UInt::Div2_DivisorGreaterOrEqual")	return false;	} public:		uint Div3(__const UIntS&ss2,UIntS*remainder=0)	{		if(this==&ss2)		{			UIntScopy_ss2(ss2);			return Div3Ref(copy_ss2,remainder);		}		else		{			return Div3Ref(ss2,remainder);		}	}		uint Div3(__const UIntS&ss2,UIntS&remainder)	{		return Div3(ss2,&remainder);	} private:	 	uint Div3Ref(__const UIntS&v,UIntS*remainder=0)	{	uint m,n,test;		test=Div_StandardTest(v,m,n,remainder);		if(test<2)			return test;		if(n==0)		{			uint r;			DivInt(v.table[0],&r);			if(remainder)			{				remainder->SetZero();				remainder->table[0]=r;			}			TTMATH_LOG("UInt::Div3")		return 0;		}		//we can only use the third division algorithm when		//the divisor is greater or equal 2^32 (has more than one 32-bit word)		++m;		++n;		m=m-n;		Div3_Division(v,remainder,m,n);		TTMATH_LOG("UInt::Div3")	return 0;	} private:	void Div3_Division(UIntSv,UIntS*remainder,uint m,uint n)	{		UInt<value_size+1>uu,vv;	UIntSq;	uint d,u_value_size,u0,u1,u2,v1,v0,j=m;				u_value_size=Div3_Normalize(v,n,d);		if(j+n==value_size)			u2=u_value_size;		else			u2=table[j+n];		Div3_MakeBiggerV(v,vv);		for(uint i=j+1;i<value_size;++i)			q.table[i]=0;		while(true)		{			u1=table[j+n-1];			u0=table[j+n-2];			v1=v.table[n-1];			v0=v.table[n-2];			uint qp=Div3_Calculate(u2,u1,u0,v1,v0);			Div3_MakeNewU(uu,j,n,u2);			Div3_MultiplySubtract(uu,vv,qp);			Div3_CopyNewU(uu,j,n);			q.table[j]=qp;			//the next loop			if(j--==0)				break;			u2=table[j+n];		}		if(remainder)			Div3_Unnormalize(remainder,n,d);	*this=q;	TTMATH_LOG("UInt::Div3_Division")	}	void Div3_MakeNewU(UInt<value_size+1>&uu,uint j,uint n,uint u_max)	{	uint i;		for(i=0;i<n;++i,++j)			uu.table[i]=table[j];		//'n' is from<1..value_size>so and 'i' is from<0..value_size>		//then table[i]is always correct (look at the declaration of 'uu')		uu.table[i]=u_max;		for(++i;i<value_size+1;++i)			uu.table[i]=0;		TTMATH_LOG("UInt::Div3_MakeNewU")	}	void Div3_CopyNewU(__const UInt<value_size+1>&uu,uint j,uint n)	{	uint i;		for(i=0;i<n;++i)			table[i+j]=uu.table[i];		if(i+j<value_size)			table[i+j]=uu.table[i];		TTMATH_LOG("UInt::Div3_CopyNewU")	}	 	void Div3_MakeBiggerV(__const UIntS&v,UInt<value_size+1>&vv)	{		for(uint i=0;i<value_size;++i)			vv.table[i]=v.table[i];		vv.table[value_size]=0;		TTMATH_LOG("UInt::Div3_MakeBiggerV")	}		 	uint Div3_Normalize(UIntS&v,uint n,uint&d)	{		//v.table[n-1]is!=0		uint bit=(uint)FindLeadingBitInWord(v.table[n-1]);		uint move=(32u-bit-1);		uint res=table[value_size-1];		d =move;		if(move>0)		{			v.Rcl(move,0);			Rcl(move,0);			res=res>>(bit+1);		}		else		{			res=0;		}		TTMATH_LOG("UInt::Div3_Normalize")	return res;	}	void Div3_Unnormalize(UIntS*remainder,uint n,uint d)	{		for(uint i=n;i<value_size;++i)			table[i]=0;		Rcr(d,0);		*remainder=*this;		TTMATH_LOG("UInt::Div3_Unnormalize")	}	uint Div3_Calculate(uint u2,uint u1,uint u0,uint v1,uint v0)	{		UInt<2>u_temp;	uint rp;	bool next_test;				u_temp.table[1]=u2;		u_temp.table[0]=u1;		u_temp.DivInt(v1,&rp);				do		{			bool decrease=false;			if(u_temp.table[1]==1)				decrease=true;			else			{				UInt<2>temp1,temp2;				UInt<2>::MulTwoWords(u_temp.table[0],v0,temp1.table+1,temp1.table);				temp2.table[1]=rp;				temp2.table[0]=u0;				if(temp1>temp2)					decrease=true;			}			next_test=false;			if(decrease)			{				u_temp.SubOne();				rp+=v1;				if(rp>=v1)//it means that there wasn't a carry (r<b from the book)					next_test=true;			}		}		while(next_test);		TTMATH_LOG("UInt::Div3_Calculate")	return u_temp.table[0];	} 	void Div3_MultiplySubtract(	UInt<value_size+1>&uu,								__const UInt<value_size+1>&vv,uint&qp)	{		//D4 (in the book)		UInt<value_size+1>vv_temp(vv);		vv_temp.MulInt(qp);		if(uu.Sub(vv_temp))		{			//there was a carry						//			//!!!this part of code was not tested			//			--qp;			uu.Add(vv);			//can be a carry from this additions but it should be ignored			//because it cancels with the borrow from uu.Sub(vv_temp)		}		TTMATH_LOG("UInt::Div3_MultiplySubtract")	} public:	 	uint Pow(UIntSpow)	{		if(pow.IsZero()&&IsZero())			//we don't define zero^zero			return 2;		UIntSstart(*this);		UIntSresult;		result.SetOne();		uint c=0;		while(!c)		{			if(pow.table[0]&1)				c+=result.Mul(start);			pow.Rcr2_one(0);			if(pow.IsZero())				break;			c+=start.Mul(start);		}		*this=result;			return (c==0)?0:1;	}	 	void Sqrt()	{	UIntSbit,temp;		if(IsZero())			return;		UIntSvalue(*this);		SetZero();		bit.SetZero();		bit.table[value_size-1]=(2147483648u>>1);				while(bit>value)			bit.Rcr(2);		while(!bit.IsZero())		{			temp=*this;			temp.Add(bit);			if(value>=temp)			{				value.Sub(temp);				Rcr(1);				Add(bit);			}			else			{				Rcr(1);			}			bit.Rcr(2);		}		TTMATH_LOG("UInt::Sqrt")	} 	 	void ClearFirstBits(uint n)	{		if(n>=value_size*32u)		{			SetZero();			TTMATH_LOG("UInt::ClearFirstBits")			return;		}		uint*p=table;		//first we're clearing the whole words		while(n>=32u)		{			*p++=0;			n -=32u;		}		if(n==0)		{			TTMATH_LOG("UInt::ClearFirstBits")			return;		}		//and then we're clearing one word which has left		//mask--all bits are set to one		uint mask=4294967295u;		mask=mask<<n;		(*p)&=mask;		TTMATH_LOG("UInt::ClearFirstBits")	}		bool IsTheHighestBitSet()__const	{		return (table[value_size-1]&2147483648u)!=0;	}		bool IsTheLowestBitSet()__const	{		return (*table&1)!=0;	}		bool IsOnlyTheHighestBitSet()__const	{#pragma clang diagnostic push#pragma clang diagnostic ignored"-Wtautological-compare"		for(uint i=0;i<value_size-1;++i)			if(table[i]!=0)				return false;#pragma clang diagnostic pop		if(table[value_size-1]!=2147483648u)			return false;	return true;	}		bool IsOnlyTheLowestBitSet()__const	{		if(table[0]!=1)			return false;		for(uint i=1;i<value_size;++i)			if(table[i]!=0)				return false;	return true;	}		bool IsZero()__const	{		for(uint i=0;i<value_size;++i)			if(table[i]!=0)				return false;	return true;	}		bool AreFirstBitsZero(uint bits)__const	{				uint index=bits/32u;		uint rest=bits %32u;		uint i;		for(i=0;i<index;++i)			if(table[i]!=0)				return false;		if(rest==0)			return true;		uint mask=4294967295u>>(32u-rest);	return (table[i]&mask)==0;	} 	 	 	template<uint argument_size>	uint FromUInt(__const UInt<argument_size>&p)	{		uint min_size=(value_size<argument_size)?value_size:argument_size;		uint i;		for(i=0;i<min_size;++i)			table[i]=p.table[i];		if(value_size>argument_size)		{				//'this' is longer than 'p'			for(;i<value_size;++i)				table[i]=0;		}		else		{			for(;i<argument_size;++i)				if(p.table[i]!=0)				{										return 1;				}		}			return 0;	}	 	template<uint argument_size>	uint FromInt(__const UInt<argument_size>&p)	{		return FromUInt(p);	}		uint FromUInt(uint value)	{		for(uint i=1;i<value_size;++i)			table[i]=0;		table[0]=value;		TTMATH_LOG("UInt::FromUInt(uint)")		//there'll never be a carry here	return 0;	}		uint FromInt(uint value)	{		return FromUInt(value);	}		uint FromInt(sint value)	{		uint c=FromUInt(uint(value));		if(c||value<0)			return 1;	return 0;	}	 	template<uint argument_size>	UIntS&operator=(__const UInt<argument_size>&p)	{		FromUInt(p);	return*this;	}		UIntS&operator=(__const UIntS&p)	{		for(uint i=0;i<value_size;++i)			table[i]=p.table[i];		TTMATH_LOG("UInt::operator=(UInt<>)")		return*this;	}		UIntS&operator=(uint i)	{		FromUInt(i);	return*this;	}		UInt(uint i)	{		FromUInt(i);	}		UIntS&operator=(sint i)	{		FromInt(i);	return*this;	}	 	UInt(sint i)	{		FromInt(i);	} 	 	uint FromUInt(ulint n)	{		table[0]=(uint)n;		if(value_size==1)		{			uint c=((n>>32u)==0)?0:1;						return c;		}		table[1]=(uint)(n>>32u);		for(uint i=2;i<value_size;++i)			table[i]=0;		TTMATH_LOG("UInt::FromUInt(ulint)")	return 0;	}	 	uint FromInt(ulint n)	{		return FromUInt(n);	}	 	uint FromInt(slint n)	{		uint c=FromUInt(ulint(n));		if(c||n<0)			return 1;	return 0;	}	 	UIntS&operator=(ulint n)	{		FromUInt(n);	return*this;	}	 	UInt(ulint n)	{		FromUInt(n);	}	 	UIntS&operator=(slint n)	{		FromInt(n);	return*this;	}	 	UInt(slint n)	{		FromInt(n);	}  		UInt(__const char*s)	{		FromString(s);	}		UInt(__const string&s)	{		FromString(s.c_str());	} 		UInt(__const wchar_t*s)	{		FromString(s);	}		UInt(__const wstring&s)	{		FromString(s.c_str());	} 	 	UInt()	{	//when macro TTMATH_DEBUG_LOG is defined	//we set special values to the table	//in order to be everywhere the same value of the UInt object	//without this it would be difficult to analyse the log file	 				for(uint i=0;i<value_size;++i)					table[i]=0xc1c1c1c1c1c1c1c1;			#endif	}		UInt(__const UIntS&u)	{		for(uint i=0;i<value_size;++i)			table[i]=u.table[i];		TTMATH_LOG("UInt::UInt(UInt<>)")	} 		template<uint argument_size>	UInt(__const UInt<argument_size>&u)	{		//look that 'size' we still set as 'value_size' and not as u.value_size		FromUInt(u);	} 		~UInt()	{	}	 	uint ToUInt()__const	{		return table[0];	}	 	uint ToUInt(uint&result)__const	{		result=table[0];		for(uint i=1;i<value_size;++i)			if(table[i]!=0)				return 1;	return 0;	}	 	uint ToInt(uint&result)__const	{		return ToUInt(result);	}	 	uint ToInt(sint&result)__const	{		result=sint(table[0]);		if((result&2147483648u)!=0)			return 1;		for(uint i=1;i<value_size;++i)			if(table[i]!=0)				return 1;	return 0;	} 	 	uint ToUInt(ulint&result)__const	{		if(value_size==1)		{			result=table[0];		}		else		{			uint low=table[0];			uint high=table[1];			result=low;			result|=(ulint(high)<<32u);			for(uint i=2;i<value_size;++i)				if(table[i]!=0)					return 1;		}	return 0;	}	 	uint ToInt(ulint&result)__const	{		return ToUInt(result);	}	 	uint ToInt(slint&result)__const	{	ulint temp;		uint c=ToUInt(temp);		result=slint(temp);		if(c||result<0)			return 1;	return 0;	}  protected:	 	double ToStringLog2(uint x)__const	{		static double log_tab[]={			1.000000000000000000,			0.630929753571457437,			0.500000000000000000,			0.430676558073393050,			0.386852807234541586,			0.356207187108022176,			0.333333333333333333,			0.315464876785728718,			0.301029995663981195,			0.289064826317887859,			0.278942945651129843,			0.270238154427319741,			0.262649535037193547,			0.255958024809815489,			0.250000000000000000		};		if(x<2||x>16)			return 0;	return log_tab[x-2];	} public:	 	template<class string_type>	void ToStringBase(string_type&result,uint b=10,bool negative=false)__const	{	UIntStemp(*this);	uint rest,table_id,index,digits;	double digits_d;	char character;		result.clear();		if(b<2||b>16)			return;		if(!FindLeadingBit(table_id,index))		{			result='0';			return;		}		if(negative)			result='-';		digits_d=table_id;//for not making an overflow in uint type		digits_d*=32u;		digits_d+=index+1;		digits_d*=ToStringLog2(b);		digits=static_castU(digits_d)+3;//plus some epsilon		if(result.capacity()<digits)			result.reserve(digits);		do		{			temp.DivInt(b,&rest);			character=static_cast<char>(Misc::DigitToChar(rest));			result.insert(result.end(),character);		}		while(!temp.IsZero());		size_t i1=negative?1:0;//the first is a hyphen (when negative is true)		size_t i2=result.size()-1;		for(;i1<i2;++i1,--i2)		{			char tempc=static_cast<char>(result[i1]);			result[i1]=result[i2];			result[i2]=tempc;		}	} 		void ToString(string&result,uint b=10)__const	{		return ToStringBase(result,b);	}	string ToString(uint b=10)__const	{		string result;		ToStringBase(result,b);		return result;	} 	void ToString(wstring&result,uint b=10)__const	{		return ToStringBase(result,b);	}	wstring ToWString(uint b=10)__const	{		wstring result;		ToStringBase(result,b);		return result;	} private:		template<class char_type>	uint FromStringBase(__const char_type*s,uint b=10,__const char_type**after_source=0,bool*value_read=0)	{	UIntSbase(b);	UIntStemp;	sint z;	uint c=0;		SetZero();		temp.SetZero();		Misc::SkipWhiteCharacters(s);		if(after_source)			*after_source=s;		if(value_read)			*value_read=false;		if(b<2||b>16)			return 1;		for(;(z=Misc::CharToDigit(*s,b))!=-1;++s)		{			if(value_read)				*value_read=true;			if(c==0)			{				temp.table[0]=z;				c+=Mul(base);//!!IMPROVE ME:there can be used MulInt here				c+=Add(temp);			}		}				if(after_source)			*after_source=s;			return (c==0)?0:1;	} public:		uint FromString(__const char*s,uint b=10,__const char**after_source=0,bool*value_read=0)	{		return FromStringBase(s,b,after_source,value_read);	}	 	uint FromString(__const string&s,uint b=10)	{		return FromString(s.c_str(),b);	}		UIntS&operator=(__const char*s)	{		FromString(s);	return*this;	}		UIntS&operator=(__const string&s)	{		FromString(s.c_str());	return*this;	} 		uint FromString(__const wchar_t*s,uint b=10,__const wchar_t**after_source=0,bool*value_read=0)	{		return FromStringBase(s,b,after_source,value_read);	}	 	uint FromString(__const wstring&s,uint b=10)	{		return FromString(s.c_str(),b);	}		UIntS&operator=(__const wchar_t*s)	{		FromString(s);	return*this;	}		UIntS&operator=(__const wstring&s)	{		FromString(s.c_str());	return*this;	} 	 	 	bool CmpSmaller(__const UIntS&l,sint index=-1)__const	{	sint i;		if(index==-1||index>=sint(value_size))			i=value_size-1;		else			i=index;		for(;i>=0;--i)		{			if(table[i]!=l.table[i])				return table[i]<l.table[i];		}	//they're equal	return false;	} 	 	bool CmpBigger(__const UIntS&l,sint index=-1)__const	{	sint i;		if(index==-1||index>=sint(value_size))			i=value_size-1;		else			i=index;		for(;i>=0;--i)		{			if(table[i]!=l.table[i])				return table[i]>l.table[i];		}	//they're equal	return false;	}	 	bool CmpEqual(__const UIntS&l,sint index=-1)__const	{	sint i;		if(index==-1||index>=sint(value_size))			i=value_size-1;		else			i=index;		for(;i>=0;--i)			if(table[i]!=l.table[i])				return false;	return true;	} 	 	bool CmpSmallerEqual(__const UIntS&l,sint index=-1)__const	{	sint i;		if(index==-1||index>=sint(value_size))			i=value_size-1;		else			i=index;		for(;i>=0;--i)		{			if(table[i]!=l.table[i])				return table[i]<l.table[i];		}	//they're equal	return true;	} 	 	bool CmpBiggerEqual(__const UIntS&l,sint index=-1)__const	{	sint i;		if(index==-1||index>=sint(value_size))			i=value_size-1;		else			i=index;		for(;i>=0;--i)		{			if(table[i]!=l.table[i])				return table[i]>l.table[i];		}	//they're equal	return true;	}	 	bool operator<(__const UIntS&l)__const	{		return CmpSmaller(l);	}	bool operator>(__const UIntS&l)__const	{		return CmpBigger(l);	}	bool operator==(__const UIntS&l)__const	{		return CmpEqual(l);	}	bool operator!=(__const UIntS&l)__const	{		return!operator==(l);	}	bool operator<=(__const UIntS&l)__const	{		return CmpSmallerEqual(l);	}	bool operator>=(__const UIntS&l)__const	{		return CmpBiggerEqual(l);	}	 	UIntSoperator-(__const UIntS&p2)__const	{	UIntStemp(*this);		temp.Sub(p2);	return temp;	}	UIntS&operator-=(__const UIntS&p2)	{		Sub(p2);	return*this;	}	UIntSoperator+(__const UIntS&p2)__const	{	UIntStemp(*this);		temp.Add(p2);	return temp;	}	UIntS&operator+=(__const UIntS&p2)	{		Add(p2);	return*this;	}	UIntSoperator*(__const UIntS&p2)__const	{	UIntStemp(*this);		temp.Mul(p2);	return temp;	}	UIntS&operator*=(__const UIntS&p2)	{		Mul(p2);	return*this;	}	UIntSoperator/(__const UIntS&p2)__const	{	UIntStemp(*this);		temp.Div(p2);	return temp;	}	UIntS&operator/=(__const UIntS&p2)	{		Div(p2);	return*this;	}	UIntSoperator%(__const UIntS&p2)__const	{	UIntStemp(*this);	UIntSremainder;			temp.Div(p2,remainder);	return remainder;	}	UIntS&operator%=(__const UIntS&p2)	{	UIntSremainder;			Div(p2,remainder);		operator=(remainder);	return*this;	}		UIntS&operator++()	{		AddOne();	return*this;	}		UIntSoperator++(int)	{	UIntStemp(*this);		AddOne();	return temp;	}	UIntS&operator--()	{		SubOne();	return*this;	}	UIntSoperator--(int)	{	UIntStemp(*this);		SubOne();	return temp;	} 	 	UIntSoperator~()__const	{		UIntStemp(*this);		temp.BitNot();	return temp;	}	UIntSoperator&(__const UIntS&p2)__const	{		UIntStemp(*this);		temp.BitAnd(p2);	return temp;	}	UIntS&operator&=(__const UIntS&p2)	{		BitAnd(p2);	return*this;	}	UIntSoperator|(__const UIntS&p2)__const	{		UIntStemp(*this);		temp.BitOr(p2);	return temp;	}	UIntS&operator|=(__const UIntS&p2)	{		BitOr(p2);	return*this;	}	UIntSoperator^(__const UIntS&p2)__const	{		UIntStemp(*this);		temp.BitXor(p2);	return temp;	}	UIntS&operator^=(__const UIntS&p2)	{		BitXor(p2);	return*this;	}	UIntSoperator>>(int move)__const	{	UIntStemp(*this);		temp.Rcr(move);	return temp;	}	UIntS&operator>>=(int move)	{		Rcr(move);	return*this;	}	UIntSoperator<<(int move)__const	{	UIntStemp(*this);		temp.Rcl(move);	return temp;	}	UIntS&operator<<=(int move)	{		Rcl(move);	return*this;	}	 private:		template<class ostream_type,class string_type>	static ostream_type&OutputToStream(ostream_type&s,__const UIntS&l)	{	string_type ss;		l.ToString(ss);		s<<ss;	return s;	} public:		friend ostream&operator<<(ostream&s,__const UIntS&l)	{		return OutputToStream<ostream,string>(s,l);	} 		friend wostream&operator<<(wostream&s,__const UIntS&l)	{		return OutputToStream<wostream,wstring>(s,l);	} private:		template<class istream_type,class string_type,class char_type>	static istream_type&InputFromStream(istream_type&s,UIntS&l)	{	string_type ss;		//char or wchar_t for operator>>	char_type z;			//operator>>omits white characters if they're set for ommiting		s>>z;		//we're reading only digits (base=10)		while(s.good()&&Misc::CharToDigit(z,10)>=0)		{			ss+=z;			z=static_cast<char_type>(s.get());		}		//we're leaving the last read character		//(it's not belonging to the value)		s.unget();		l.FromString(ss);	return s;	} public:		friend istream&operator>>(istream&s,UIntS&l)	{		return InputFromStream<istream,string,char>(s,l);	} 		friend wistream&operator>>(wistream&s,UIntS&l)	{		return InputFromStream<wistream,wstring,wchar_t>(s,l);	} 	  private:	uint Rcl2_one(uint c);	uint Rcr2_one(uint c);	uint Rcl2(uint bits,uint c);	uint Rcr2(uint bits,uint c); public:	static __const char*LibTypeStr();	static LibTypeCode LibType();	uint Add(__const UIntS&ss2,uint c=0);	uint AddInt(uint value,uint index=0);	uint AddTwoInts(uint x2,uint x1,uint index);	static uint AddVector(__const uint*ss1,__const uint*ss2,uint ss1_size,uint ss2_size,uint*result);	uint Sub(__const UIntS&ss2,uint c=0);	uint SubInt(uint value,uint index=0);	static uint SubVector(__const uint*ss1,__const uint*ss2,uint ss1_size,uint ss2_size,uint*result);	static sint FindLeadingBitInWord(uint x);	static sint FindLowestBitInWord(uint x);	static uint SetBitInWord(uint&value,uint bit);	static void MulTwoWords(uint a,uint b,uint*result_high,uint*result_low);	static void DivTwoWords(uint a,uint b,uint c,uint*r,uint*rest);}; template<>class UInt<0>{public:	uint table[1];	void Mul2Big(__const UInt<0>&,UInt<0>&){};	void SetZero(){};	uint AddTwoInts(uint,uint,uint){ return 0;};};}//namespace     namespace ttmath{		template<uint value_size>	__const char*UIntS::LibTypeStr()	{		 					static __const char info[]="asm_gcc_32";			return info;	}		template<uint value_size>	LibTypeCode UIntS::LibType()	{		 					LibTypeCode info=asm_gcc_32;			return info;	} 	 	 	template<uint value_size>	uint UIntS::Add(__const UIntS&ss2,uint c)	{	uint b=value_size;	uint*p1=table;	uint*p2=const_cast<uint*>(ss2.table);		//we don't have to use TTMATH_REFERENCE_ASSERT here		//this algorithm doesn't require it									uint dummy,dummy2;			//	this part should be compiled with gcc						__asm__ __volatile__(				"xorl %%edx,%%edx				\n"				"negl %%eax						\n"//CF=1 if rax!=0,CF=0 if rax==0			"1:									\n"				"movl (%%esi,%%edx,4),%%eax	\n"				"adcl %%eax,(%%ebx,%%edx,4)	\n"							"incl %%edx						\n"				"decl %%ecx						\n"			"jnz 1b								\n"				"adc %%ecx,%%ecx				\n"				:"=c"(c),"=a"(dummy),"=d"(dummy2)				:"0"(b),"1"(c),"b"(p1),"S"(p2)				:"cc","memory");					return c;	} 		template<uint value_size>	uint UIntS::AddInt(uint value,uint index)	{	uint b=value_size;	uint*p1=table;	uint c;											uint dummy,dummy2;			__asm__ __volatile__(							"subl %%edx,%%ecx				\n"			"1:									\n"				"addl %%eax,(%%ebx,%%edx,4)	\n"			"jnc 2f								\n"								"movl $1,%%eax					\n"				"incl %%edx						\n"				"decl %%ecx						\n"			"jnz 1b								\n"			"2:									\n"				"setc %%al						\n"				"movzx %%al,%%edx				\n"				:"=d"(c), "=a"(dummy),"=c"(dummy2)				:"0"(index),"1"(value),"2"(b),"b"(p1)				:"cc","memory");						return c;	} 		template<uint value_size>	uint UIntS::AddTwoInts(uint x2,uint x1,uint index)	{	uint b=value_size;	uint*p1=table;	uint c;											uint dummy,dummy2;			__asm__ __volatile__(							"subl %%edx,%%ecx				\n"								"addl %%esi,(%%ebx,%%edx,4)	\n"				"incl %%edx						\n"				"decl %%ecx						\n"			"1:									\n"				"adcl %%eax,(%%ebx,%%edx,4)	\n"			"jnc 2f								\n"				"mov $0,%%eax					\n"				"incl %%edx						\n"				"decl %%ecx						\n"			"jnz 1b								\n"			"2:									\n"				"setc %%al						\n"				"movzx %%al,%%eax				\n"				:"=a"(c),"=c"(dummy),"=d"(dummy2)				:"0"(x2),"1"(b), "2"(index),"b"(p1),"S"(x1)				:"cc","memory");						return c;	} 		template<uint value_size>	uint UIntS::AddVector(__const uint*ss1,__const uint*ss2,uint ss1_size,uint ss2_size,uint*result)	{				uint rest=ss1_size-ss2_size;		uint c;												//	this part should be compiled with gcc		uint dummy1,dummy2,dummy3;			__asm__ __volatile__(				"push %%edx							\n"				"xor %%edx,%%edx					\n"//edx=0,cf=0			"1:										\n"				"mov (%%esi,%%edx,4),%%eax			\n"				"adc (%%ebx,%%edx,4),%%eax			\n"				"mov %%eax,(%%edi,%%edx,4)			\n"				"inc %%edx							\n"				"dec %%ecx							\n"			"jnz 1b									\n"				"adc %%ecx,%%ecx					\n"//ecx has the cf state				"pop %%eax							\n"//eax=rest				"or %%eax,%%eax					\n"				"jz 3f								\n"								"xor %%ebx,%%ebx					\n"//ebx=0				"neg %%ecx							\n"//setting cf from ecx				"mov %%eax,%%ecx					\n"//ecx=rest and is!=0			"2:										\n"				"mov (%%esi,%%edx,4),%%eax		\n"				"adc %%ebx,%%eax					\n"				"mov %%eax,(%%edi,%%edx,4)		\n"				"inc %%edx							\n"				"dec %%ecx							\n"			"jnz 2b									\n"				"adc %%ecx,%%ecx					\n"			"3:										\n"				:"=a"(dummy1),"=b"(dummy2),"=c"(c), "=d"(dummy3)				:  "1"(ss2), "2"(ss2_size),"3"(rest),"S"(ss1),"D"(result)				:"cc","memory");					return c;	}	 	template<uint value_size>	uint UIntS::Sub(__const UIntS&ss2,uint c)	{	uint b=value_size;	uint*p1=table;	uint*p2=const_cast<uint*>(ss2.table);		//we don't have to use TTMATH_REFERENCE_ASSERT here		//this algorithm doesn't require it						uint dummy,dummy2;			__asm__ __volatile__(				"xorl %%edx,%%edx				\n"				"negl %%eax						\n"//CF=1 if rax!=0,CF=0 if rax==0			"1:									\n"				"movl (%%esi,%%edx,4),%%eax	\n"				"sbbl %%eax,(%%ebx,%%edx,4)	\n"							"incl %%edx						\n"				"decl %%ecx						\n"			"jnz 1b								\n"				"adc %%ecx,%%ecx				\n"				:"=c"(c),"=a"(dummy),"=d"(dummy2)				:"0"(b),"1"(c),"b"(p1),"S"(p2)				:"cc","memory");					return c;	} 		template<uint value_size>	uint UIntS::SubInt(uint value,uint index)	{	uint b=value_size;	uint*p1=table;	uint c;											uint dummy,dummy2;			__asm__ __volatile__(							"subl %%edx,%%ecx				\n"			"1:									\n"				"subl %%eax,(%%ebx,%%edx,4)	\n"			"jnc 2f								\n"								"movl $1,%%eax					\n"				"incl %%edx						\n"				"decl %%ecx						\n"			"jnz 1b								\n"			"2:									\n"				"setc %%al						\n"				"movzx %%al,%%edx				\n"				:"=d"(c), "=a"(dummy),"=c"(dummy2)				:"0"(index),"1"(value),"2"(b),"b"(p1)				:"cc","memory");								return c;	} 		template<uint value_size>	uint UIntS::SubVector(__const uint*ss1,__const uint*ss2,uint ss1_size,uint ss2_size,uint*result)	{				uint rest=ss1_size-ss2_size;		uint c;												//	this part should be compiled with gcc		uint dummy1,dummy2,dummy3;			__asm__ __volatile__(				"push %%edx							\n"				"xor %%edx,%%edx					\n"//edx=0,cf=0			"1:										\n"				"mov (%%esi,%%edx,4),%%eax			\n"				"sbb (%%ebx,%%edx,4),%%eax			\n"				"mov %%eax,(%%edi,%%edx,4)			\n"				"inc %%edx							\n"				"dec %%ecx							\n"			"jnz 1b									\n"				"adc %%ecx,%%ecx					\n"//ecx has the cf state				"pop %%eax							\n"//eax=rest				"or %%eax,%%eax					\n"				"jz 3f								\n"								"xor %%ebx,%%ebx					\n"//ebx=0				"neg %%ecx							\n"//setting cf from ecx				"mov %%eax,%%ecx					\n"//ecx=rest and is!=0			"2:										\n"				"mov (%%esi,%%edx,4),%%eax		\n"				"sbb %%ebx,%%eax					\n"				"mov %%eax,(%%edi,%%edx,4)		\n"				"inc %%edx							\n"				"dec %%ecx							\n"			"jnz 2b									\n"				"adc %%ecx,%%ecx					\n"			"3:										\n"				:"=a"(dummy1),"=b"(dummy2),"=c"(c), "=d"(dummy3)				:  "1"(ss2), "2"(ss2_size),"3"(rest),"S"(ss1),"D"(result)				:"cc","memory");					return c;	} 		template<uint value_size>	uint UIntS::Rcl2_one(uint c)	{	uint b=value_size;	uint*p1=table;						uint dummy,dummy2;		__asm__ __volatile__(			"xorl %%edx,%%edx			\n"//edx=0			"negl %%eax					\n"//CF=1 if eax!=0,CF=0 if eax==0		"1:								\n"			"rcll $1,(%%ebx,%%edx,4)	\n"			"incl %%edx					\n"			"decl %%ecx					\n"		"jnz 1b							\n"			"adcl %%ecx,%%ecx			\n"			:"=c"(c),"=a"(dummy),"=d"(dummy2)			:"0"(b),"1"(c),"b"(p1)			:"cc","memory");					return c;	} 		template<uint value_size>	uint UIntS::Rcr2_one(uint c)	{	uint b=value_size;	uint*p1=table;						uint dummy;		__asm__ __volatile__(			"negl %%eax						\n"//CF=1 if eax!=0,CF=0 if eax==0		"1:									\n"			"rcrl $1,-4(%%ebx,%%ecx,4)	\n"			"decl %%ecx						\n"		"jnz 1b								\n"			"adcl %%ecx,%%ecx				\n"			:"=c"(c),"=a"(dummy)			:"0"(b),"1"(c),"b"(p1)			:"cc","memory");					return c;	} 			template<uint value_size>	uint UIntS::Rcl2(uint bits,uint c)	{				uint b=value_size;	uint*p1=table;						uint dummy,dummy2,dummy3;		__asm__ __volatile__(			"push %%ebp						\n"						"movl %%ecx,%%esi				\n"			"movl $32,%%ecx				\n"			"subl %%esi,%%ecx				\n" //ecx=32-bits			"movl $-1,%%edx				\n" //edx=-1 (all bits set to one)			"shrl %%cl,%%edx				\n" //shifting (0->edx->cf) (cl times)			"movl %%edx,%%ebp				\n" //ebp=edx=mask			"movl %%esi,%%ecx				\n"			"xorl %%edx,%%edx				\n"			"movl %%edx,%%esi				\n"			"orl %%eax,%%eax				\n"			"cmovnz %%ebp,%%esi			\n" //if(c)esi=mask else esi=0		"1:									\n"			"roll %%cl,(%%ebx,%%edx,4)		\n"			"movl (%%ebx,%%edx,4),%%eax	\n"			"andl %%ebp,%%eax				\n"			"xorl %%eax,(%%ebx,%%edx,4)	\n"			"orl %%esi,(%%ebx,%%edx,4)	\n"			"movl %%eax,%%esi				\n"						"incl %%edx						\n"			"decl %%edi						\n"		"jnz 1b								\n"						"and $1,%%eax					\n"			"pop %%ebp						\n"			:"=a"(c),"=D"(dummy),"=S"(dummy2),"=d"(dummy3)			:"0"(c),"1"(b),"b"(p1),"c"(bits)			:"cc","memory");					return c;	} 		template<uint value_size>	uint UIntS::Rcr2(uint bits,uint c)	{		uint b=value_size;	uint*p1=table;						uint dummy,dummy2,dummy3;			__asm__ __volatile__(			"push %%ebp						\n"						"movl %%ecx,%%esi				\n"			"movl $32,%%ecx				\n"			"subl %%esi,%%ecx				\n" //ecx=32-bits			"movl $-1,%%edx				\n" //edx=-1 (all bits set to one)			"shll %%cl,%%edx				\n" //shifting (cf<-edx<-0) (cl times)			"movl %%edx,%%ebp				\n" //ebp=edx=mask			"movl %%esi,%%ecx				\n"			"xorl %%edx,%%edx				\n"			"movl %%edx,%%esi				\n"			"addl %%edi,%%edx				\n"			"decl %%edx						\n" //edx is pointing at the end of the table (on last word)			"orl %%eax,%%eax				\n"			"cmovnz %%ebp,%%esi			\n" //if(c)esi=mask else esi=0		"1:									\n"			"rorl %%cl,(%%ebx,%%edx,4)		\n"			"movl (%%ebx,%%edx,4),%%eax	\n"			"andl %%ebp,%%eax				\n"			"xorl %%eax,(%%ebx,%%edx,4)	\n"			"orl %%esi,(%%ebx,%%edx,4)	\n"			"movl %%eax,%%esi				\n"						"decl %%edx						\n"			"decl %%edi						\n"		"jnz 1b								\n"						"roll $1,%%eax					\n"			"andl $1,%%eax					\n"			"pop %%ebp						\n"			:"=a"(c),"=D"(dummy),"=S"(dummy2),"=d"(dummy3)			:"0"(c),"1"(b),"b"(p1),"c"(bits)			:"cc","memory");					return c;	} 	 	template<uint value_size>	sint UIntS::FindLeadingBitInWord(uint x)	{	sint result;						uint dummy;				__asm__ (				"movl $-1,%1  \n"				"bsrl %2,%0  \n"				"cmovz %1,%0  \n"				:"=r"(result),"=&r"(dummy)				:"r"(x)				:"cc");			return result;	} 	 	template<uint value_size>	sint UIntS::FindLowestBitInWord(uint x)	{	sint result;						uint dummy;				__asm__ (				"movl $-1,%1  \n"				"bsfl %2,%0  \n"				"cmovz %1,%0  \n"				:"=r"(result),"=&r"(dummy)				:"r"(x)				:"cc");			return result;	} 		template<uint value_size>	uint UIntS::SetBitInWord(uint&value,uint bit)	{				uint old_bit;		uint v=value;							__asm__ (			"btsl %%ebx,%%eax		\n"			"setc %%bl				\n"			"movzx %%bl,%%ebx		\n"						:"=a"(v),"=b"(old_bit)			:"0"(v),"1"(bit)			:"cc");				value=v;	return old_bit;	} 	 	template<uint value_size>	void UIntS::MulTwoWords(uint a,uint b,uint*result_high,uint*result_low)	{	 	uint result1_;	uint result2_;						__asm__ (					"mull %%edx			\n"			:"=a"(result1_),"=d"(result2_)			:"0"(a), "1"(b)			:"cc");				*result_low=result1_;		*result_high=result2_;	} 	 	 		template<uint value_size>	void UIntS::DivTwoWords(uint a,uint b,uint c,uint*r,uint*rest)	{		uint r_;		uint rest_;		 											__asm__ (			"divl %%ecx				\n"			:"=a"(r_),"=d"(rest_)			:"0"(b),"1"(a),"c"(c)			:"cc");				*r=r_;		*rest=rest_;	} }//namespace      
